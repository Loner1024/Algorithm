# 如何实现LRU缓存淘汰算法

缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的 CPU 缓存、数据库缓存、浏览器缓存等等。

缓存的大小有限，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留，需要缓存淘汰策略来决定。常见的策略有三种：先进先出策略 FIFO（First In，First Out）、最少使用策略 LFU（Least Frequently Used）、最近最少使用策略 LRU（Least Recently Used）。

## 五花八门的链表结构

从下面这个图中我们看到，数组需要一块**连续的内存空间**来存储，对内存的要求比较高。如果我们申请一个 100MB 大小的数组，当内存中没有连续的、足够大的存储空间时，即便内存的剩余总可用空间大于 100MB，仍然会申请失败。

而链表不需要连续的内存空间，它通过“指针”将一组零散的内存块串联起来使用。

![d5d5bee4be28326ba3c28373808a62cd](链表.assets/d5d5bee4be28326ba3c28373808a62cd.jpg)

链表结构五花八门，最常见的有：单链表、双向链表和循环链表。

### 单链表

链表通过指针将一组零散的内存块串联在一起。我们把内存块称为链表的“**结点**”。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址。我们把这记录下个结点地址的指针叫做**后继指针**。

![b93e7ade9bb927baad1348d9a806ddeb](链表.assets/b93e7ade9bb927baad1348d9a806ddeb.jpg)

其中，第一个结点称为**头结点**，最后一个结点称为**尾结点**。头结点用来记录链表的基地址，有了它，我们可以遍历得到整条链表。尾结点的后继指针指向一个**空地址NULL**，表明这是链表上最后一个结点。

与数组一样，链表也支持数据的查找、插入和删除操作。

在链表中插入或者删除一个数据，我们并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就是不连续的。![452e943788bdeea462d364389bd08a17](链表.assets/452e943788bdeea462d364389bd08a17.jpg)

针对链表的插入和删除操作，我们只需要考虑相邻结点的指针改变，对应的时间复杂度是O(1)。

在链表中插入和删除一个数据相比数组更加快速，但是要想随机访问某个元素就没有数组那么高效了。因为链表中的数据是非随机存储的，所以无法像数组哪有，根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址，而是需要根据指针一个节点一个节点地依次遍历，知道找到相应的结点。

### 循环链表和双向链表



