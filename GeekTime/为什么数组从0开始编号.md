# 为什么数组从0开始编号

在大部分编程语言中，数组都是从0开始编号的。

## 如何实现随机访问

**数组（Array）是一种线性表数据结构。它用一组练习的内存空间，来存储一组具有相同类型的数据。**

**线性表(Linear List)**，线性表就是数据排成一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。除了数组外，链表、队列、栈等也是线性表结构。

![b6b71ec46935130dff5c4b62cf273477](为什么数组从0开始编号.assets/b6b71ec46935130dff5c4b62cf273477.jpg)

与线性表相对应的是**非线性表**，比如二叉树、堆、图等。之所以称为非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。

![6ebf42641b5f98f912d36f6bf86f6569](为什么数组从0开始编号.assets/6ebf42641b5f98f912d36f6bf86f6569.jpg)

**连续的内存空间和相同的数据类型**：通过这两个限制，实现了“随机访问”。但同样的，这两个限制也让数组的很多操作变得非常低效，比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。

我们知道，计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：

```
a[i]_address = base_address + i * data_type_size
```

其中 data_type_size 表示数组中每个元素的大小。

## 低效的“插入”和删除

假设数组的长度为 n，现在，如果我们需要将一个数据插入到数组中的第 k 个位置。为了把第 k 个位置腾出来，给新来的数据，我们需要将第 k～n 这部分的元素都顺序地往后挪一位。

如果在数组的末尾插入元素，那就不需要移动数据了，这时的时间复杂度为 O(1)。但如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是 O(n)。 因为我们在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为 (1+2+…n)/n=O(n)。

跟插入数据类似，如果我们要删除第 k 个位置的数据，为了内存的连续性，也需要搬移数据，不然中间就会出现空洞，内存就不连续了。

和插入类似，如果删除数组末尾的数据，则最好情况时间复杂度为 O(1)；如果删除开头的数据，则最坏情况时间复杂度为 O(n)；平均情况时间复杂度也为 O(n)。

## 为什么

从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”。前面也讲到，如果用 a 来表示数组的首地址，a[0] 就是偏移为 0 的位置，也就是首地址，a[k] 就表示偏移 k 个 type_size 的位置，所以计算 a[k] 的内存地址只需要用这个公式：

```
a[k]_address = base_address + k * type_size
```

但是，如果数组从 1 开始计数，那我们计算数组元素 a[k] 的内存地址就会变为：

```
a[k]_address = base_address + (k-1)*type_size
```

如果从1开始标号，那么在访问我们想要的数组元素时就多了一个-1的操作，而从0开始，直观，并且减少了一次减法操作，效率更高。